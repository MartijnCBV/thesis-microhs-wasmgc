\chapter{Plan}\label{ch:plan}
For part two of the thesis, we have one main goal, namely to be able to run a set of standard Haskell benchmarks on the Wasm 3.0 backend of MicroHs. To achieve this, we will need to perform the following tasks:
\begin{enumerate}
    \item \textbf{Runtime Support for Necessary Combinators and Primitives:} There are two approaches we can take to achieve this. The first approach is to implement runtime support for all combinators and primitives that are used when we compile the benchmark programs using MicroHs. This involves implementing many combinators and primitives, which may be time-consuming and uninteresting for the purposes of this thesis. The second approach is to define a new simplified prelude that is optimized for generating as few different types of combinators and primitives as possible. This prelude would provide the necessary functionality for the benchmarks while minimizing the number of combinators and primitives that need to be implemented in the runtime. We will evaluate both approaches and choose the one that is most feasible within the time constraints of this thesis.
    \item \textbf{Benchmark Selection and Setup:} We will select a subset of the Nofib benchmark suite~\cite{nofib} that does not rely on complex features such as concurrency, foreign function interfaces, or certain types of I/O. We will also need to set up an environment that can automatically run the benchmarks and collect performance data. Since we will be comparing both Wasm and native binaries, we will need to ensure that the measurements are fair and consistent across different platforms.
    \item \textbf{Performance Evaluation:} There are multiple different performance comparisons we can make. First, we will compare the performance of the Wasm 3.0 backend against MicroHs's existing C backend. This will give us insight into the performance impact of using Wasm with GC compared to a traditional native backend. Second, we will compare the performance of the Wasm 3.0 backend against the MicroHs Wasm backend (through emscripten). This will allow us to evaluate the benefits of using Wasm with GC compared to traditional Wasm without GC. Third, we will compare the performance of the Wasm 3.0 backend against the GHC Wasm backend. To make this comparison fair, we can compare the relative performance of both backends to their respective native backends (i.e., MicroHs C backend and GHC's native backend). This will help us understand how well the Wasm 3.0 backend performs in relation to a mainstream Haskell compiler. Last, we can employ a Wasm-to-Wasm optimizer such as Binaryen~\cite{binaryen} to optimize the generated Wasm binaries and evaluate the performance improvements that can be achieved through such optimizations and how this compares to the optimizability of other backends. For the general evaluation process we will make use of the ACM SIGPLAN Evaluation Guidelines~\cite{acm_sigplan_evaluation}.
\end{enumerate}

If this main goal is achieved with sufficient time remaining, we can explore additional directions to further enhance the Wasm 3.0 backend of MicroHs:
\begin{enumerate}
    \item \textbf{Lightweight Threads:} Implementing lightweight threads using stack switching can provide concurrency support in the Wasm 3.0 backend. Every thread would be represented by its own stack and the program could switch between these stacks to achieve concurrency. This would involve implementing a scheduler to manage the threads and ensure that they are executed fairly.
    \item \textbf{Runtime Optimizations:} The current runtime system is not the most optimal, for example, strict primitives are implemented using recursion while this is not necessary. As a first step we can remove this recursion to potentially improve performance. Other directions are testing different stack allocation strategies for the LAS as well as removing unused combinators and primitives from the runtime when a program is compiled.
    \item \textbf{Debugging Tooling:} Developing debugging tools specifically for the Wasm 3.0 backend can aid in diagnosing and fixing issues that may arise during development. This could include tools for inspecting the state of the runtime, visualizing the execution of programs, and identifying performance bottlenecks.
    \item \textbf{JavaScript Interoperability:} Since we are targeting the web, adding support for the Haskell-JavaScript foreign function interface can enable Haskell code to interact with JavaScript code running in the same environment. This would potentially allow features such as DOM manipulation, event handling, and access to browser APIs from Haskell code.
\end{enumerate}