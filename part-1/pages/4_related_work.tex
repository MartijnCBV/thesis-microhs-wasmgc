\chapter{Related Work}\label{ch:related_work}
\section{Haskell for the Web}
Historically, running Haskell code in web browsers has been achieved using GHCJS~\cite{ghcjs}, a compiler that transpiles Haskell code to JavaScript. While GHCJS allows Haskell code to run in browsers, it suffers from multiple problems. Due to it having to include large parts of the GHC runtime system resulting in large bundle sizes~\cite{yorhel}. Furthermore, the development has lagged behind GHC itself, causing GHCJS to not be able to take advantage of the latest compiler optimizations and language extensions~\cite{ghcjs}. 

Other Haskell-to-JavaScript compilers exist, such as UHC~\cite{uhcjs} Fay~\cite{fay}, and Haste~\cite{haste}. However, each of these compilers have not seen active development in recent years, and thus are not suitable for modern Haskell web development. 

% maybe mention https://dl.acm.org/doi/10.1145/3547621
WebAssembly has emerged as a promising alternative for running Haskell code on the web. Historically, this has been achieved through the Asterius project~\cite{asterius}, which is a Haskell-to-Wasm compiler based on GHC. The project has however been deprecated in favour of GHC's own Wasm backend~\cite{ghcwasm}, which is actively being developed as part of GHC itself. Both Asterius and GHC's Wasm backend however target traditional Wasm without GC support, which results in them having to include a memory management system in produced Wasm binaries, leading to larger binary sizes and increased complexity.

Other functional programming languages that share a large amount of similarities with Haskell have also been used for web development. Elm~\cite{elm} is a purely functional programming language that compiles to JavaScript and is designed specifically for building web applications. It features a strong type system and emphasizes simplicity and ease of use. Similarly, PureScript~\cite{purescript} is another strongly-typed functional programming language that compiles to JavaScript with a syntax and semantics inspired by Haskell. While they may look like Haskell, there are many semantic differences and are thus not directly applicable to this thesis's goals.

\section{WebAssembly with Garbage Collection}
WebAssembly's GC support is a relatively recent addition to the WebAssembly specification, aimed at improving the performance and efficiency of languages that rely on GC, such as Haskell, Java, and C\#. Since its introduction, it has seen wide adoption in various projects and languages. It is supported by all major web browsers, including Chromium-based browsers, Firefox, and Safari, as well as non-web environments like Node.js, Deno and Wasmtime~\cite{wasm3}. Furthermore there is support for GC specific optimizations in popular Wasm optimzers such as Binaryen~\cite{wasm3,binaryen}. And it is targeted by multiple compilers, such as Dart, Kotlin/Wasm, WasOCaml, Hoot, and J2CL/Wasm~\cite{dart,kotlin,wasocaml,hoot,j2clwasm,wasmperf}.

As demonstrated by the V8 team, using Wasm's with GC is highly optimizable, both by compile time optimizations as well as runtime optimizations~\cite{v8blog}. They demonstrated that using a compile time optimizer such as Binaryen with Wasm with GC can produce binaries that have up to 2 times higher throughput (higher is better). Likewise, they demonstrated that enabling runtime optimizations in V8 can lead to lower latency (lower is better) by porting the Google Sheets Calc Engine to Wasm with GC.

Performance testing of binaries produced by the Kotlin compiler shows that the Wasm backend produces binaries that are significantly faster than the JavaScript backend, and is approaching the performance of the JVM backend~\cite{kotlin}. When looking at functional programming languages, the WasOCaml compiler targets Wasm with GC, per their benchmarks, binaries produced by WasOCaml are slower by an almost constant factor of circa 2 times when compared to native OCaml binaries~\cite{wasocaml}. They show that a major slowdown is caused by the exception handling mechanism in Wasm when using V8, i.e. a raise instruction is about 100 times slower in Wasm when compared to native OCaml. Due to their dependence on other Wasm proposals such as tail calls, WasOCaml could only be benchmarked on V8, which supports all required proposals. When looking at Wasm backends for Haskell, the GHC Wasm backend has been benchmarked against GHC's native backend, showing that the Wasm backend is between 4 to 1 times slower than the native backend depending on the benchmark, most likely due to not using Wasm with GC and other modern Wasm features~\cite{wasmperf}. 

% \section{Relevant WebAssembly Proposals and features}

\section{Combinator Based Compilers and Runtime Systems}
The combinator based compiler backend and runtime MicroHs uses is based on the work of Turner~\cite{turner}, who introduced the idea of compiling programs to SKI combinator calculus and executing them on an SK-reduction machine. Turner made use of this system in multiple functional programming languages, such as the SASL and KRC languages which were intended for research and teaching purposes~\cite{sasl,krc}. Later, the system was also used in the production Miranda language~\cite{miranda}, which has had significant influence on the design of Haskell.

While modern runtimes for lazy functional programming languages such as GHC are implemented using abstract machines such as the Spineless Tagless G-machine (STG)~\cite{stg}, experimenting with combinator based runtimes is still relevant as our focus is not on optimizing the runtime system itself, but rather on exploring the effects of using Wasm GC support as opposed to shipping our own GC when compiling Haskell to Wasm.

% \section{Performance Evaluations of Haskell Compilers}
% nofib